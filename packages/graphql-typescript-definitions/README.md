# `graphql-typescript-definitions`

> Generate TypeScript definition files from .graphql documents

## Installation

```
npm install graphql-typescript-definitions --save-dev
```

or, with Yarn:

```
yarn add graphql-typescript-definitions --dev
```

## Usage

This package will generate matching `.d.ts` files for each `.graphql` file you specify. It will generate types in the following format:

* A default export for the type that will be generated by a GraphQL loader (GraphQL’s `DocumentNode` type, but augmented as `graphql-typed`’s `DocumentNode` which includes additional type details about the operation).

* An interface for each query, mutation, and fragment, named `<OpertionName><Query | Mutation | Fragment>Data`. For example, `query Home {}` becomes `export interface HomeQueryData {}`.

* A namespace for each operation that includes any nested types. Nested types are named in pascal case using their keypath from the root of the operation. For example, if we imagine the following GraphQL schema (using the [GraphQL IDL](https://www.graph.cool/docs/faq/graphql-idl-schema-definition-language-kr84dktnp0/)):

  ```graphql
  type Person {
    name: String!
    relatives: [Person!]!
  }

  type Query {
    person: Person
  }
  ```

  and the following query:

  ```graphql
  query Someone {
    person {
      name
      relatives {
        name
      }
    }
  }
  ```

  The following exports would be generated:

  ```typescript
  export interface SomeoneQueryData {
    person?: SomeoneQueryData.Person | null;
  }

  export namespace SomeoneQueryData {
    export interface Person {
      name: string;
      relatives: SomeoneQueryData.PersonRelatives[];
    }

    export interface PersonRelatives {
      name: string;
    }
  }
  ```

  This allows you to use the full query’s type, as well as any of the subtypes that make up that query type. This is particularly useful for list or nullable types, where you can directly the access the underlying type without any additional help from TypeScript:

  ```typescript
  import someoneQueryDocument, {SomeoneQueryData} from './Someone.graphql';

  let data: SomeoneQueryData;
  let person: SomeoneQueryData.Person;
  ```

### Configuration

This tool consumes a [`.graphqlconfig`](https://github.com/prisma/graphql-config) file, typically placed in the root of the project. This configuration file is compatible with the [VSCode extension](https://github.com/prisma/vscode-graphql) to provide syntax highlighting and autocomplete suggestions. The configuration file supports a single nameless project or multiple named projects, with each project linked to a schema and a set of include and exclude globbing patterns. Upon processing a schema file, the schema’s types will be extracted to `types.ts` (or `${projectName}-types.ts`, if the project is named) and written to the `schema-types-path` (or use the `schemaTypesPath` extension as an override). Note that your config should supply include and exclude globbing patterns as _relative_ paths (relative to the location of the `.graphqlconfig`).

See the [official specification documentation](https://github.com/prisma/graphql-config/blob/master/specification.md#use-cases) for more detail and examples.

#### Examples

A single nameless project configuration

```json
{
  "schemaPath": "build/schema.json",
  "includes": "app/**/*.graphql"
}
```

A multi-project configuration

```json
{
  "projects": {
    "foo": {
      "schemaPath": "build/schema/foo.json",
      "includes": "app/foo/**/*.graphql"
    },
    "bar": {
      "schemaPath": "build/schema/bar.json",
      "includes": "app/bar/**/*.graphql"
    }
  }
}
```

A project configuration with a `schemaTypesPath` override

```json
{
  "projects": {
    "foo": {
      "schemaPath": "build/schema/foo.json",
      "includes": "app/foo/**/*.graphql"
    },
    "bar": {
      "schemaPath": "build/schema/bar.json",
      "includes": "app/bar/**/*.graphql",
      "extensions": {
        "schemaTypesPath": "app/bar/types/graphql.ts"
      }
    }
  }
}
```

### Type Generation

#### Nullability

As demonstrated in the root `person` field in the example above, nullable fields are represented as optional types, in a union with `null`. Nullable items in list fields (i.e., `[Person]!`) are represented as a union type with `null`.

#### Interfaces and Unions

Interface an union fields are represented as union types in cases where there are spreads that could result in different fields on different concrete types. The type names for these cases are named the same as the default naming (pascal case version of the keypath for the field), but with the type condition appended to the end. All cases not covered by fragments are extracted into a type with a postpended `Other` name.

```graphql
# Schema
interface Named {
  name: String!
}

type Person implements Named {
  name: String!
  occupation: String
}

type Dog implements Named {
  name: String!
  legs: Int!
}

type Cat implements Named {
  name: String!
  livesLeft: Int!
}

type Horse implements Named {
  name: String!
  topSpeed: Float!
}

type Query {
  named: Named
}
```

```graphql
# Query
query SomeNamed {
  named {
    name
    ... on Person {
      occupation
    }
    ... on Dog {
      legs
    }
  }
}
```

```typescript
// generated types
export interface SomeNamedData {
  named?:
    | SomeNamedData.NamedPerson
    | SomeNamedData.NamedDog
    | SomeNamedData.NamedOther
    | null;
}

export namespace SomeNamedData {
  export interface NamedPerson {
    __typename: 'Person';
    name: string;
    occupation?: string | null;
  }
  export interface NamedDog {
    __typename: 'Dog';
    name: string;
    legs: number;
  }
  export interface NamedOther {
    __typename: 'Cat' | 'Horse';
    name: string;
  }
}
```

Note that the above example assumes that you specify the `--add-typename` argument. These types are only useful when a typename is included either explicitly or with this argument, as otherwise there is no simple way for TypeScript to disambiguate the union type.

#### Schema Types

Input types (enums, input objects, and custom scalars) are generated once, in a central location, and imported within each typing file. You can use this file to reference these types in other application code as well; in particular, GraphQL enums are turned into corresponding TypeScript `enum`s. This file is specified using the `--schema-types-path` argument (detailed below), and the format for the generated enums can be specified using the `--enum-format` option.

### CLI

```sh
yarn run graphql-typescript-definitions 'src/**/*.graphql' --schema-path 'build/schema.json' --schema-types-path 'src/schema.ts'
```

Optionally, you can pass the `--watch` flag in order to regenerate the TypeScript definition files on changes to the GraphQL files. You can also pass the `--add-typename` flag in order to always generate a `__typename` field for object types, and an `--enum-format` type which specifies the casing to use for enum types generated from the schema.

### CLI

```sh
graphql-typescript-definitions --schema-types-path app/types
```

As noted above, the configuration of your schema and GraphQL documents is done via a `.graphqlconfig` file, as this allows configuration to shared between tools. The CLI does support a few additional options, though:

* `--schema-types-path`: specifies where to write schema types (**REQUIRED**)
* `--watch`: watches the include globbing patterns for changes and re-processes files (default = `false`)
* `--cwd`: run tool for `.graphqlconfig` located in this directory (default = `process.cwd()`)
* `--add-typename`: adds a `__typename` field to every object type (default = `true`)
* `--enum-format`: specifies output format for enum types (default = `undefined`)
  * Options: `camel-case`, `pascal-case`, `snake-case`, `screaming-snake-case`
  * `undefined` results in using the unchanged name from the schema (verbatim)

#### Examples

```sh
# run tool for .graphqlconfig in current directory, produces ./app/graphql/types.ts
graphql-typescript-definitions --schema-types-path app/graphql

# run watcher for .graphqlconfig in current directory, produces ./app/graphql/types.ts
graphql-typescript-definitions --schema-types-path app/graphql --watch

# run tool for .graphqlconfig in a child directory, produces ./src/app/graphql/types.ts
graphql-typescript-definitions --cwd src --schema-types-path app/graphql
```

### Node

```js
const {Builder} = require('graphql-typescript-definitions');

const builder = new Builder({
  schemaTypesPath: 'app/graphql',
});

builder.on('build', (build) => {
  // See the source file for details on the shape of the object returned here
  console.log(build);
});

builder.on('error', (error) => {
  console.error(error);
});

// Optionally, you can pass {watch: true} here to re-run on changes
builder.run();
```

As with the CLI, you can pass options to customize the build and behavior:

* `watch`
* `enumFormat` (use the exported `EnumFormat` enum)
* `graphQLFiles`
* `schemaPath`
* `schemaTypesPath`
